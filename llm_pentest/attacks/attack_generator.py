import json
import logging
import os
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass, asdict
from pathlib import Path

from ..utils.scrapers import (
    ArxivScraper,
    GitHubScraper,
    RedditScraper,
    OWASPScraper
)
from ..utils.classifier import AttackTypeClassifier

class AttackData:
    def __init__(self, attack_type: str, prompt: str, description: str, payload: Optional[str] = None, source: Optional[str] = None, timestamp: Optional[float] = None):
        self.attack_type = attack_type
        self.prompt = prompt
        self.description = description
        self.payload = payload
        self.source = source
        self.timestamp = timestamp or datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
    def to_dict(self) -> Dict:
        return {
            "type": self.attack_type,
            "prompt": self.prompt,
            "description": self.description,
            "payload": self.payload,
            "source": self.source,
            "timestamp": self.timestamp
        }
        
    @classmethod
    def from_dict(cls, data: Dict) -> 'AttackData':
        return cls(
            attack_type=data["type"],
            prompt=data["prompt"],
            description=data["description"],
            payload=data.get("payload"),
            source=data.get("source"),
            timestamp=data.get("timestamp")
        )

class AttackGenerator:
    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        self.data: List[AttackData] = []
        self.load_data()
        
    def load_data(self):
        """Load attack data from JSON file."""
        data_file = self.data_dir / "attack_data.json"
        if data_file.exists():
            with open(data_file, 'r') as f:
                data = json.load(f)
                self.data = [AttackData.from_dict(item) for item in data]
                
    def save_data(self):
        """Save attack data to JSON file."""
        data_file = self.data_dir / "attack_data.json"
        with open(data_file, 'w') as f:
            json.dump([attack.to_dict() for attack in self.data], f, indent=2)
            
    def add_attack(self, attack: AttackData):
        """Add a new attack to the collection."""
        self.data.append(attack)
        self.save_data()
        
    def get_attacks_by_type(self, attack_type: str) -> List[AttackData]:
        """Get all attacks of a specific type."""
        return [attack for attack in self.data if attack.attack_type == attack_type]
        
    def generate_prompt(self, attack_type: str, base_prompt: str) -> str:
        """Generate an attack prompt based on type and base prompt."""
        attacks = self.get_attacks_by_type(attack_type)
        if not attacks:
            raise ValueError(f"No attacks found for type: {attack_type}")
            
        # Use the most recent attack of this type
        attack = sorted(attacks, key=lambda x: x.timestamp)[-1]
        return attack.prompt.format(base_prompt=base_prompt)
        
    def get_attack_types(self) -> List[str]:
        """Get all unique attack types."""
        return list(set(attack.attack_type for attack in self.data))

    def update_data(self, keywords: List[str]):
        """Update attack data from various sources."""
        scrapers = [
            ArxivScraper(),
            GitHubScraper(),
            RedditScraper(),
            OWASPScraper()
        ]
        
        new_data = []
        for scraper in scrapers:
            try:
                logging.info(f"Collecting data from {scraper.__class__.__name__}")
                items = scraper.collect_data(keywords)
                for item in items:
                    attack_data = AttackData(
                        attack_type=item.get('attack_type', 'unknown'),
                        prompt=item.get('prompt', ''),
                        description=item.get('description', ''),
                        payload=item.get('payload'),
                        source=item.get('source'),
                        timestamp=item.get('timestamp')
                    )
                    new_data.append(attack_data)
            except Exception as e:
                logging.error(f"Error collecting from {scraper.__class__.__name__}: {str(e)}")
                continue
                
        if new_data:
            # Remove duplicates based on prompt
            existing_prompts = {item.prompt for item in self.data}
            unique_new_data = [item for item in new_data if item.prompt not in existing_prompts]
            self.data.extend(unique_new_data)
            
            # Save updated data
            if self.data_dir:
                os.makedirs(self.data_dir, exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                output_file = self.data_dir / f"llm_pentest_data_{timestamp}.json"
                with open(output_file, 'w') as f:
                    json.dump([attack.to_dict() for attack in self.data], f, indent=2)
                logging.info(f"Saved updated data to {output_file}")
                
            return len(unique_new_data)
        return 0

    def generate_attack_payload(self, attack_type: str, base_prompt: str) -> str:
        """Generate an attack payload based on the attack type and base prompt."""
        if not self.data:
            logging.warning("No data available for attack generation")
            return base_prompt

        # Filter data for the specific attack type
        attack_data = [item for item in self.data if item.attack_type == attack_type]
        if not attack_data:
            logging.warning(f"No data found for attack type: {attack_type}")
            return base_prompt

        # Get the most recent example
        example = max(attack_data, key=lambda x: x.timestamp)
        
        # Generate the attack payload
        payload = f"{example.prompt}\n\n{example.description}"
        return payload 