import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json
import os
from pathlib import Path
from .scrapers import (
    ArxivScraper,
    GitHubScraper,
    RedditScraper,
    OWASPScraper
)

class LLMMonitor:
    def __init__(self, 
                 data_dir: str = "output",
                 check_interval: int = 3600,  # 1 hour
                 max_history: int = 30):  # 30 days
        """
        Initialize the LLM monitoring system.
        
        Args:
            data_dir: Directory to store collected data
            check_interval: Time between checks in seconds
            max_history: Maximum number of days to keep history
        """
        self.data_dir = Path(data_dir)
        self.check_interval = check_interval
        self.max_history = max_history
        self.scrapers = [
            ArxivScraper(),
            GitHubScraper(),
            RedditScraper(),
            OWASPScraper()
        ]
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
        self.setup_logging()
        
        # Create data directory if it doesn't exist
        self.data_dir.mkdir(exist_ok=True)
        
    def setup_logging(self):
        """Configure logging for the monitor."""
        log_file = self.data_dir / "monitor.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        
    def load_existing_data(self) -> Dict:
        """Load existing collected data."""
        data_file = self.data_dir / "llm_techniques.json"
        if data_file.exists():
            with open(data_file, 'r') as f:
                return json.load(f)
        return {"techniques": [], "last_update": None}
        
    def save_data(self, data: Dict):
        """Save collected data with timestamp."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        data["last_update"] = timestamp
        
        # Save main data file
        main_file = self.data_dir / "llm_techniques.json"
        with open(main_file, 'w') as f:
            json.dump(data, f, indent=2)
            
        # Save historical copy
        hist_file = self.data_dir / f"llm_techniques_{timestamp}.json"
        with open(hist_file, 'w') as f:
            json.dump(data, f, indent=2)
            
        self.cleanup_old_files()
        
    def cleanup_old_files(self):
        """Remove old historical files beyond max_history."""
        hist_files = sorted(self.data_dir.glob("llm_techniques_*.json"))
        if len(hist_files) > self.max_history:
            for old_file in hist_files[:-self.max_history]:
                old_file.unlink()
                
    def collect_new_techniques(self) -> List[Dict]:
        """Collect new techniques from all sources."""
        new_techniques = []
        for scraper in self.scrapers:
            try:
                self.logger.info(f"Collecting from {scraper.__class__.__name__}")
                techniques = scraper.collect_data()
                new_techniques.extend(techniques)
            except Exception as e:
                self.logger.error(f"Error collecting from {scraper.__class__.__name__}: {str(e)}")
        return new_techniques
        
    def update_techniques(self):
        """Update the techniques database with new findings."""
        existing_data = self.load_existing_data()
        existing_techniques = {t["id"]: t for t in existing_data.get("techniques", [])}
        
        new_techniques = self.collect_new_techniques()
        updated = False
        
        for technique in new_techniques:
            if technique["id"] not in existing_techniques:
                existing_techniques[technique["id"]] = technique
                updated = True
                self.logger.info(f"Added new technique: {technique['title']}")
                
        if updated:
            existing_data["techniques"] = list(existing_techniques.values())
            self.save_data(existing_data)
            
    def run_continuous(self):
        """Run the monitor continuously."""
        self.logger.info("Starting continuous monitoring...")
        try:
            while True:
                self.update_techniques()
                self.logger.info(f"Sleeping for {self.check_interval} seconds...")
                time.sleep(self.check_interval)
        except KeyboardInterrupt:
            self.logger.info("Monitoring stopped by user")
        except Exception as e:
            self.logger.error(f"Error in continuous monitoring: {str(e)}")
            
    def get_new_techniques_since(self, since: Optional[datetime] = None) -> List[Dict]:
        """Get techniques added since a specific date."""
        data = self.load_existing_data()
        if since is None:
            # Default to last 24 hours
            since = datetime.now() - timedelta(days=1)
            
        return [
            t for t in data["techniques"]
            if datetime.strptime(t["added_date"], "%Y-%m-%d %H:%M:%S") > since
        ] 